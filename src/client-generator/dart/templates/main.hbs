// ignore_for_file: non_constant_identifier_names, camel_case_types, constant_identifier_names, unused_local_variable

part of 'api_client.dart';

{{> utils}}

enum HttpMethod { GET, POST, PUT, DELETE }

const apiVersion = '{{version}}';

class {{className}}HttpError extends Error {
  int status;
  String code;
  Map<String, dynamic> payload;
  HttpException? innerException;

  ApiClientHttpError(
    this.status,
    this.code,
    this.payload, [
    this.innerException,
  ]);
}


{{#each methods}}
  {{> declaration}}
{{/each}}


{{#each methods}}
  {{> error}}
{{/each}}


class _{{className}} {
  final Dio dio;

  _{{className}}({required this.dio});

  Future<dynamic> request(
    HttpMethod method,
    String url, {
    Map<String, dynamic>? query,
    Map<String, dynamic>? body,
  }) async {
    late final Response response;

    try {
      response = await dio.request(
        url,
        data: body,
        queryParameters: query,
        options: Options(
          validateStatus: (status) => status != null && status < 300,
          responseType: ResponseType.json,
          contentType: Headers.jsonContentType,
          method: method.name,
        ),
      );
    } on DioException catch (e) {
      if (e.response!.statusCode == 400) {
        final errorCode = e.response!.data['code'];
        if (errorCode == null || errorCode == '') {
          if (e.response != null &&
              e.response?.data != null &&
              e.response?.data['devInfo'] != null) {
            debugPrint(jsonEncode(e.response!.data['devInfo']));
          }
          throw HttpException(e.response!.data['message'] ?? 'Invalid request');
        }
        throw ApiClientHttpError(
          e.response!.statusCode!,
          errorCode,
          e.response!.data,
        );
      }
      rethrow;
    }

    if (response.statusCode == 200) {
      return response.data;
    }
  }

  {{#each methods}}
  
    {{> method className=../className}}
  {{/each}}
}