{{#docs}}
  {{{title}}}
  {{#if description}}{{{description}}}{{/if}}
  {{#if deprecated}}@Deprecated({{coalesce deprecationMessage 'Should not be used and will be removed in the future.' }}){{/if}}
{{/docs}}
Future<Result<{{zodRecord (concat methodName "response") returnType}}, 
{{#if errors}}
  {{methodName}}_Errors
{{else}}
  ERROR_PLACEHOLDER
{{/if}}>> {{methodName}}({{#if arguments}}  
    {{#if isRPC}}
      {{zodRecord (concat methodName "body") arguments.body}} data
    {{else}}
  {
          {{#if arguments.params}}
            required {{zodRecord (concat methodName "params") arguments.params}} params,
          {{/if}}
          {{#if arguments.query}}
            {{zodRecord (concat methodName "query") arguments.query}}? query,
          {{/if}}
          {{#if arguments.body}}
            required {{zodRecord (concat methodName "body") arguments.body}} body,
          {{/if}}
          {{#if arguments.headers}}
            required {{zodRecord (concat methodName "headers") arguments.headers}} headers,
          {{/if}}
  }
    {{/if}}
{{/if}}) async {
  {{#if deprecated~}}
    print('[{{methodName}}] endpoint was deprecated - {{coalesce deprecationMessage 'should not be used and will be removed in the future.' }}');
  {{~/if}}
    dynamic result;

  {{#if errors}}
    try {
      result =  await {{> request}}
    } on {{className}}HttpError catch (e) {
      final {{methodName}}_Errors error = {{methodName}}_Errors.values.firstWhere(
        (x) => x.name == e.code,
      );
      return Result.failure(error, e.stackTrace);
    }
  {{else}}
    result =  await {{> request}}
  {{/if}}

  {{#if returnType}}
    return Result.success({{hidrateFromMap "result" (concat methodName "response") returnType}});
  {{else}}
    return Result.success(null);
  {{/if}}
}
